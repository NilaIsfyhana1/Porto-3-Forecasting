# -*- coding: utf-8 -*-
"""Portofolio 3_ Forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18YS7RRaBTxZxIB4NOQViVznUivdpPRqy
"""

!pip install pmdarima

"""## Preparation"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
import matplotlib.pyplot as plt

from statsmodels.tsa.arima.model import ARIMA
from pmdarima import auto_arima # autoarima

from sklearn.metrics import mean_squared_error

import plotly.graph_objects as go

file_path = 'dummy_apotek_sales.csv'  # add .csv if your file extension is csv
df = pd.read_csv(file_path)
df

df.info()

import plotly.express as px
import plotly.graph_objects as go

fig = go.Figure([go.Scatter(name = 'true',x=df.index, y=df['sales'])])
fig.update_xaxes(rangeslider_visible=True)
fig.show()

def acf_pacf(data, fitur):# Original
    fig, axes = plt.subplots(3,3, figsize = (20,10))
    axes[0, 0].plot(data[fitur]); axes[0, 0].set_title('Original Series')
    plot_acf(data[fitur], ax=axes[0, 1])
    plot_pacf(data[fitur], ax=axes[0, 2])

    # 1st Differencing
    axes[1, 0].plot(data[fitur].diff(1)); axes[1, 0].set_title('1st Differencing')
    plot_acf(data[fitur].diff(1).dropna(), ax=axes[1, 1])
    plot_pacf(data[fitur].diff(1).dropna(), ax=axes[1, 2])


    # 2nd Differencing
    axes[2, 0].plot(data[fitur].diff(2)); axes[2, 0].set_title('2nd Differencing')
    plot_acf(data[fitur].diff(2).dropna(), ax=axes[2, 1])
    plot_pacf(data[fitur].diff(2).dropna(), ax=axes[2, 2])

    plt.show()

acf_pacf(df, 'sales')

"""### Data Splitting"""

train = df.iloc[:-6]  # Semua data kecuali 6 data terakhir
test = df.iloc[-6:]   # 6 data terakhir untuk testing

train

# Pisahkan variabel endogen (target) dan eksogen
y_train = train["sales"]
y_test = test["sales"]
X_train = train[["ad_budget", "discount"]]
X_test = test[["ad_budget", "discount"]]

"""### Modelling"""

import warnings
warnings.filterwarnings("ignore", category=FutureWarning)

model = auto_arima(
    y = y_train,
    X = X_train, # exogen
    seasonal = True, # seasonal disetting true
    m = 12, # per 10 baris
    stepwise = True,# random search, kalau False akan grid search
    trace = True, # agar keluar hasil setiap step prosesnya
    suppress_warnings = True
)

"""### Evaluasi"""

forecast = model.predict(n_periods = 6, X = X_test)
forecast

# Visualisasi hasil prediksi dibandingkan data asli
fig = go.Figure()
fig.add_trace(go.Scatter(x=df.index, y=df['sales'], mode='lines', name='Actual'))  # Data asli
fig.add_trace(go.Scatter(x=test.index, y=forecast, mode='lines', name='Forecast'))  # Hasil prediksi untuk test set
fig.update_layout(title='ARIMA Forecast vs Actual (Testing Data)', xaxis_title='Time', yaxis_title='sales')
fig.show()

# Hitung RMSE antara hasil prediksi dan data testing
mse = mean_squared_error(y_test, forecast)
print(f"RMSE dari model pada 10 data terakhir adalah {mse ** 0.5}")

"""## Model Regresi (selain arima)"""

df.head()

"""### Data Preparation"""

WINDOW_SIZE = 12

# Make a copy of the Bitcoin historical data with block reward feature
df_windowed = df.copy()

# Add windowed columns
for i in range(WINDOW_SIZE): # Shift values for each step in WINDOW_SIZE
  df_windowed[f"sales-{i+1}"] = df_windowed["sales"].shift(periods=i+1)
df_windowed.head(20)

# hapus NaN
df_windowed = df_windowed.dropna()
df_windowed

"""### Data Splitting"""

X = df_windowed.drop(columns = ['date', 'sales'])
y = df_windowed['sales']

# Split data: test size hanya 1 baris terakhir
X_train, X_test = X[:-5], X[-5:]  # Semua kecuali terakhir untuk training, terakhir untuk testing
y_train, y_test = y[:-5], y[-5:]  # Sama untuk target

# Check shapes
print("X_train shape:", X_train.shape)
print("y_train shape:", y_train.shape)
print("X_test shape:", X_test.shape)
print("y_test shape:", y_test.shape)

"""### Modeliing"""

import xgboost as xgb
from sklearn.metrics import mean_squared_error

# Inisialisasi model XGBoost Regressor
model = xgb.XGBRegressor()

# Inisialisasi list untuk menyimpan prediksi
predictions = []

# Loop melalui setiap baris di X_test
for i in range(len(X_test)):
    # Latih model dengan data X_train dan y_train
    model.fit(X_train, y_train)

    # Prediksi nilai untuk baris pertama di X_test
    y_pred = model.predict(X_test.iloc[[i]])
    predictions.append(y_pred[0])

    # Tambahkan baris pertama X_test dan y_pred ke X_train dan y_train
    X_train = pd.concat([X_train, X_test.iloc[[i]]])
    y_train = pd.concat([y_train, pd.Series(y_pred[0], index=[X_test.index[i]])])

# Evaluasi model
mse = mean_squared_error(y_test, predictions)
rmse = mse ** 0.5
print(f"RMSE: {rmse}")

print(predictions)
print(y_test)

"""### Evaluasi"""

# Visualisasi hasil prediksi dibandingkan data asli
fig = go.Figure()
fig.add_trace(go.Scatter(x=df_windowed.index, y=df_windowed['sales'], mode='lines', name='Actual'))  # Data asli
fig.add_trace(go.Scatter(x=X_test.index, y=predictions, mode='lines', name='Forecast'))  # Hasil prediksi untuk test set
fig.update_layout(title='ARIMA Forecast vs Actual (Testing Data)', xaxis_title='Time', yaxis_title='Sales')
fig.show()

# Hitung RMSE antara hasil prediksi dan data testing
mse = mean_squared_error(y_test, predictions)
print(f"RMSE dari model pada 10 data terakhir adalah {mse ** 0.5}")

"""## Time Series Cross Validation

ARIMA
"""

from sklearn.model_selection import TimeSeriesSplit
from pmdarima import auto_arima
from sklearn.metrics import mean_squared_error
import plotly.graph_objects as go
import numpy as np

# Tentukan jumlah pembagian untuk validasi silang
n_splits = 5

# Buat objek TimeSeriesSplit
tscv = TimeSeriesSplit(n_splits=n_splits)

# Daftar untuk menyimpan metrik evaluasi untuk setiap lipatan
rmse_scores = []

# Iterasi melalui lipatan
for fold, (train_index, test_index) in enumerate(tscv.split(df), start=1):
    # Bagi data menjadi data latih dan data uji
    X_train, X_test = df.iloc[train_index], df.iloc[test_index]
    y_train, y_test = df["sales"].iloc[train_index], df["sales"].iloc[test_index]

    # Pisahkan variabel eksogen
    X_train_exog = X_train[["ad_budget", "discount"]]
    X_test_exog = X_test[["ad_budget", "discount"]]

    # Sesuaikan pembedaan musiman atau m
    try:
        # Latih model menggunakan auto_arima
        model = auto_arima(
            y=y_train,
            X=X_train_exog,
            seasonal=True,
            m=12,
            stepwise=True,
            trace=False,
            suppress_warnings=True,
            error_action='ignore',
        )
    except ValueError as e:
        print(f"Lipatan {fold}: Kesalahan selama auto_arima - {e}")
        continue

    # Hasilkan prakiraan untuk set pengujian
    forecast = model.predict(n_periods=len(X_test_exog), X=X_test_exog)
    mse = mean_squared_error(y_test, forecast)
    rmse = mse ** 0.5
    rmse_scores.append(rmse)
    print(f"Lipatan {fold} RMSE: {rmse}")

    # --- Visualisasi ---
    # Gabungkan data latih dan uji untuk visualisasi
    y_full = pd.concat([y_train, y_test])
    forecast_full = pd.Series(data=np.nan, index=y_full.index)
    forecast_full.iloc[len(y_train):] = forecast

    # Buat plot menggunakan plotly.graph_objects
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=y_full.index, y=y_full, mode='lines', name='Aktual (Latih + Uji)'))
    fig.add_trace(go.Scatter(x=y_full.index, y=forecast_full, mode='lines', name='Prediksi (Uji)'))
    fig.update_layout(
        title=f'Prakiraan vs Aktual (Lipatan {fold})',
        xaxis_title='Waktu',
        yaxis_title='Penjualan',
    )
    fig.show()

# Hitung rata-rata RMSE di semua lipatan
avg_rmse = np.mean(rmse_scores)
print(f"\nRata-rata RMSE di {n_splits} lipatan: {avg_rmse}")

"""### Beberapa Model Regresi

#### XGBoost
"""

import pandas as pd
import numpy as np
import xgboost as xgb
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_squared_error
import plotly.graph_objects as go


def time_series_cross_validation_with_full_plot(df, target_column, exogenous_columns, window_size=12, n_splits=5, model_input=xgb.XGBRegressor()):
    # Data Preparation with Windowing
    df_windowed = df.copy()
    for i in range(window_size):
        df_windowed[f"{target_column}-{i+1}"] = df_windowed[target_column].shift(periods=i+1)
    df_windowed = df_windowed.dropna()

    X = df_windowed.drop(columns=['date', target_column])  # Assuming 'date' column exists
    y = df_windowed[target_column]

    # Time Series Cross-Validation
    tscv = TimeSeriesSplit(n_splits=n_splits)
    rmse_scores = []

    for fold, (train_index, test_index) in enumerate(tscv.split(df_windowed), start=1):
        X_train, X_test = X.iloc[train_index], X.iloc[test_index]
        y_train, y_test = y.iloc[train_index], y.iloc[test_index]

        model = model_input
        model.fit(X_train, y_train)
        predictions = model.predict(X_test)

        mse = mean_squared_error(y_test, predictions)
        rmse = mse ** 0.5
        rmse_scores.append(rmse)
        print(f"Fold {fold} RMSE: {rmse}")

        # Combine train and test for visualization
        y_full = pd.concat([y_train, y_test])  # Full y (train + test)
        predictions_full = pd.Series(data=np.nan, index=y_full.index)  # Create a full-sized Series for predictions
        predictions_full.iloc[len(y_train):] = predictions  # Add test predictions

        # Visualization for each fold
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=y_full.index, y=y_full, mode='lines', name='Actual (Train + Test)'))  # Data asli (Train + Test)
        fig.add_trace(go.Scatter(x=y_full.index, y=predictions_full, mode='lines', name='Predicted (Test)'))  # Prediksi hanya di Test
        fig.update_layout(
            title=f'Forecast vs Actual (Fold {fold})',
            xaxis_title='Time',
            yaxis_title=target_column,
        )
        fig.show()

    avg_rmse = np.mean(rmse_scores)
    print(f"\nAverage RMSE across {n_splits} folds: {avg_rmse}")
    return avg_rmse


# Example usage (replace with your actual DataFrame and column names)
# Assuming your data is in a dataframe called 'df'
avg_rmse = time_series_cross_validation_with_full_plot(df, 'sales', ['ad_budget', 'discount'], model_input=xgb.XGBRegressor())

"""#### Linear Regression"""

# import linear regression
from sklearn.linear_model import LinearRegression

time_series_cross_validation_with_full_plot(df, 'sales', ['ad_budget', 'discount'], model_input = LinearRegression())

"""#### Random Forest Regressor"""

# import
from sklearn.ensemble import RandomForestRegressor
time_series_cross_validation_with_full_plot(df, 'sales', ['ad_budget', 'discount'], model_input = RandomForestRegressor())

"""#### SVM"""

# import
from sklearn.svm import SVR
time_series_cross_validation_with_full_plot(df, 'sales', ['ad_budget', 'discount'], model_input = SVR())

"""## Kesimpulan"""

import pandas as pd
import numpy as np

# Assuming you have a DataFrame called 'results_df' with columns:
# 'Model' (e.g., 'ARIMA', 'XGBoost', 'Linear Regression', etc.)
# 'RMSE' (the RMSE value for each model)
# Create the results DataFrame (replace with your actual results)
results_df = pd.DataFrame({
    'Model': ['ARIMA', 'XGBoost', 'Linear Regression', 'Random Forest', 'SVM'],
    'RMSE': [100, 50, 75, 60, 80]  # Replace with your actual RMSE values
})


def plot_rmse_comparison(results_df):
    # Sort models by RMSE for better visualization
    results_df = results_df.sort_values('RMSE')

    import matplotlib.pyplot as plt
    plt.figure(figsize=(10, 6))
    plt.bar(results_df['Model'], results_df['RMSE'], color='skyblue')
    plt.xlabel("Model")
    plt.ylabel("RMSE")
    plt.title("Performance Comparison of Time Series Forecasting Models")
    plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for readability
    plt.tight_layout()  # Adjust layout to prevent labels from overlapping
    plt.show()

    # Display a table
    print(results_df)

plot_rmse_comparison(results_df)

"""dari semua yang sudah dicoba terlihat bahwa model XGBoost adalah yang paling baik"""